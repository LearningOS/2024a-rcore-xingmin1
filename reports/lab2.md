## 实现功能总结

实现 mmap 和 munmap 系统调用

* **os/src/mm/address.rs**:

  * 为 `SimpleRange` 结构体添加了 `overlap` 方法，用于检查两个范围是否有重叠。
* **os/src/mm/memory_set.rs**:

  * 增加了 `map_area_overleap` 方法，用于判断给定的内存区域是否与现有区域重叠。
  * 添加了 `get_map_area_overleap` 方法，用于获取所有与指定范围重叠的内存区域。
  * 实现了 `remove_framed_areas` 方法，用于解除指定范围内的内存映射。
  * 为 `MapArea` 结构体添加了 `get_len` 方法，以获取映射区域的长度。
* **os/src/mm/mod.rs**:

  * 在导出列表中加入了 `SimpleRange` 类型，以便其他模块使用。
* **os/src/syscall/process.rs**:

  * 实现了 `validate_mmap_params` 函数，用于校验 `mmap`  的参数合法性。
  * 完成了 `sys_mmap` 系统调用的实现，包括参数校验、内存区域检查及映射操作。
  * 实现了 `sys_munmap` 系统调用，用于解除指定范围内的内存映射，并进行相应的参数校验。
* **os/src/task/mod.rs**:

  * 增加了 `get_current_memory_set_mut` 方法，用于获取当前运行任务的内存集。
  * 实现了 `current_memory_set_mut` 函数，作为全局接口以便其他模块访问当前任务的内存集。
* **os/src/task/task.rs**:

  * 为 `TaskControlBlock` 结构体添加了 `get_memory_set_mut` 方法，用于获取内存集的可变引用。

---

## 问答题

### 1. 请列举 SV39 页表页表项的组成，描述其中的标志位有何作用？

SV39 页表项（PTE）由 64 位组成，其结构如下：

* **位 0（V 位）** ：有效位（Valid）。指示该页表项是否有效，V\=1 表示有效，V\=0 表示无效。
* **位 1（R 位）** ：可读位（Readable）。R\=1 表示该页面可读。
* **位 2（W 位）** ：可写位（Writable）。W\=1 表示该页面可写。
* **位 3（X 位）** ：可执行位（Executable）。X\=1 表示该页面可执行。
* **位 4（U 位）** ：用户位（User）。U\=1 表示用户模式可访问，U\=0 表示用户模式不可访问。
* **位 5（G 位）** ：全局位（Global）。G\=1 表示该页表项在所有地址空间中都有效（通常用于内核页表项）。
* **位 6（A 位）** ：访问位（Accessed）。由硬件设置，A\=1 表示该页面被访问过（读取或写入）。
* **位 7（D 位）** ：脏页位（Dirty）。由硬件设置，D\=1 表示该页面被写入过。
* **位 8-9**：保留位，未定义，必须为 0。
* **位 10-53（PPN 位）** ：物理页号（Physical Page Number）。用于指示页面在物理内存中的位置。
* **位 54-63**：保留位，未定义，必须为 0。

这些标志位的作用如下：

* **V 位**：用于判断页表项是否有效，防止访问未映射的地址。
* **R/W/X 位**：控制页面的读、写、执行权限，提供内存保护机制。
* **U 位**：用于区分用户模式和内核模式的访问权限，保护内核空间不被用户程序非法访问。
* **G 位**：在多进程环境下，全局位可避免频繁刷新 TLB，提升性能。
* **A/D 位**：用于页面置换算法（如 LRU），帮助操作系统管理内存。

---

### 2. 缺页

#### a) 请问哪些异常可能是缺页导致的？

缺页可能导致以下异常：

* **指令页面错误异常（Instruction Page Fault）** ：当 CPU 在取指令时，发现对应的页面不存在或无效。
* **加载页面错误异常（Load Page Fault）** ：当 CPU 执行加载指令（如 `lw`）时，发现对应的页面不存在或无效。
* **存储/AMO 页面错误异常（Store/AMO Page Fault）** ：当 CPU 执行存储指令（如 `sw`）或原子内存操作（AMO）时，发现对应的页面不存在或无效。

---

#### b) 发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。

发生缺页时，以下寄存器的值非常重要：

* **​`scause`​** **寄存器**：指示异常的原因，包含异常类型，例如加载页面错误、存储页面错误或指令页面错误。
* **​`stval`​** **寄存器**：保存导致异常的虚拟地址，即 CPU 试图访问但未映射的地址。
* **​`sepc`​** **寄存器**：保存引发异常的指令地址，便于异常处理完成后恢复程序执行。

操作系统通过读取这些寄存器，确定异常类型和发生异常的地址，从而进行相应的处理。

---

#### c) 这样做有哪些好处？

采用 Lazy 策略，即延迟页面的实际分配和加载，直到页面被首次访问，具有以下好处：

1. **节省内存资源**：只为真正使用到的页面分配物理内存，避免了预先分配大量未使用内存造成的浪费。
2. **加快程序启动速度**：程序启动时无需加载所有页面，减少了 I/O 操作和内存分配的开销，使程序能够更快地开始运行。
3. **提高系统效率**：避免了对不必要页面的加载和映射，降低了系统的总体负载，提升了性能。

---

#### d) 处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？

首先，计算需要映射的页面数量：

* 10GB \= 10 × 1024MB \= 10 × 1024 × 1024KB
* 页面大小为 4KB
* 页面数量 ≈ (10 × 1024 × 1024) / 4 ≈ 2,621,440 个页面

页表的层级和占用：

* **第三级页表（叶子节点）** ：

  * 每个页表页包含 512 个页表项
  * 需要的页表页数量：2,621,440 / 512 ≈ 5,123 页
* **第二级页表**：

  * 每个页表页也包含 512 个页表项
  * 需要的页表页数量：5,123 / 512 ≈ 10 页
* **第一级页表（根页表）** ：

  * 只有 1 个页表页

总共需要的页表页数：

* 1（第一级）+ 10（第二级）+ 5,123（第三级）≈ **5,134 页**

总共占用的内存大小：

* 5,134 页 × 4KB/页 ≈ **21MB**

因此，映射 10GB 连续内存，需要大约 **21MB** 的页表内存。

---

#### e) 请简单思考如何才能实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。

实现 Lazy 策略的思路：

1. **延迟分配物理内存**：当进程请求大量内存（例如通过 `mmap` 或 `sbrk`），操作系统仅在虚拟地址空间中预留相应的地址范围，但不立即分配物理内存或建立页表映射。
2. **页表项设置为无效**：对应的页表项标记为无效（V 位为 0），表示该页面尚未分配物理内存。
3. **处理缺页异常**：当进程首次访问该虚拟地址时，由于页表项无效，CPU 会触发缺页异常。
4. **在异常处理程序中分配内存**：操作系统的异常处理程序捕获到缺页异常后，检查该地址是否属于延迟分配区域。如果是，则为该页面分配物理内存，更新页表项（设置正确的 PPN 和权限位），将 V 位置 1。
5. **重新执行指令**：异常处理完成后，返回用户态，重新执行导致缺页的指令。

---

#### f) 此时页面失效如何表现在页表项(PTE)上？

当页面失效（例如被换出到磁盘）时，页表项的变化如下：

* **V 位（有效位）清零**：将页表项的 V 位设置为 0，表示该页表项无效，页面不在物理内存中。

---

### 3. 双页表与单页表

#### a) 在单页表情况下，如何更换页表？

在单页表情况下，每个进程都有自己的页表，用户态和内核态共享同一张页表。更换页表的步骤为：

* **更新 satp 寄存器**：在进程上下文切换时，操作系统将下一个进程的页表根节点物理页号加载到 satp（Supervisor Address Translation and Protection）寄存器中。
* **刷新 TLB（可选）** ：执行 `sfence.vma` 指令，刷新快表（TLB），确保新的页表映射生效，避免使用旧的地址映射。

---

#### b) 单页表情况下，如何控制用户态无法访问内核页面？

在单页表情况下，控制用户态无法访问内核页面的方法是：

* **使用页表项的 U 位（User 位）** ：在页表项中，对于属于内核空间的页面，将 U 位设置为 0，表示该页面只能在内核模式下访问。
* **权限检查**：当 CPU 处于用户模式时，尝试访问 U 位为 0 的页面会触发权限异常（如加载/存储页错误），从而阻止用户态进程访问内核空间。

---

#### c) 单页表有何优势？（回答合理即可）

单页表的优势包括：

1. **减少内存占用**：所有进程的内核空间映射相同，共享一份内核空间的页表项，节省了内存资源。
2. **上下文切换开销小**：在进程切换时，只需更新用户空间的页表部分，内核空间的映射保持不变，减少了页表切换的开销。
3. **访问效率高**：内核可以直接访问用户空间的数据，无需额外的地址转换，有利于系统调用和数据交换。
4. **TLB 命中率高**：由于内核空间的映射始终有效，TLB 中缓存的内核地址转换可以在不同进程间复用，减少了 TLB 缺失，提高了性能。

---

#### d) 双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？

**双页表实现下，更换页表的时机**：

* **在用户态和内核态切换时**：由于用户态和内核态使用不同的页表，进入内核态（如系统调用、异常、中断）时，需要切换到内核页表；返回用户态时，切换回用户页表。
* **在进程上下文切换时**：当切换到另一个进程时，需要加载目标进程的用户页表或内核页表。

**如果我编写一个单页表的操作系统，选择在以下时机更换页表**：

* **仅在进程上下文切换时更换页表**：由于所有进程共享相同的内核空间映射，且用户态和内核态使用同一张页表，因此在同一进程内，从用户态切换到内核态不需要更换页表。

# **荣誉准则**

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 **以下各位** 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

    > ChatGPT 关于rust语法方面的内容
    >
2. 此外，我也参考了 **以下资料** ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

    > 课本
    >
3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。
4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。